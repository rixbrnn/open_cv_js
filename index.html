<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Opencv Project</title>
    <script async src="js/opencv.js"></script>
  </head>
  <body>
    <input type="file" id="file_input" />
    <canvas id="permanentCanvas"></canvas>
    <canvas id="output"></canvas>

    <div>
      <label for="filter_select">Select a Filter:</label>
      <div>
        <button onclick="previewFilter('GRAY')">Grayscale</button>
        <button onclick="previewFilter('THRESHOLD')">Threshold</button>
        <button onclick="previewFilter('CANNY')">Canny Edge Detection</button>
        <button onclick="previewFilter('BLUR')">Gaussian Blur</button>
        <button onclick="previewFilter('ERODE')">Erosion</button>
        <button onclick="previewFilter('DILATE')">Dilation</button>
        <button onclick="previewFilter('SEPIA')">Sepia</button>
        <button onclick="previewFilter('BRIGHTNESS')">
          Brightness Adjustment
        </button>
        <button onclick="previewFilter('CONTRAST')">Contrast Adjustment</button>
        <button onclick="previewFilter('COLOR_OVERLAY')">
          Random Color Overlay
        </button>
      </div>
      <input
        type="range"
        id="filterIntensity"
        min="0"
        max="1"
        step="0.1"
        value="1"
        oninput="adjustIntensity()"
      />
    </div>
  </body>

  <script>
    let img_input = document.getElementById("input_image");
    let file_input = document.getElementById("file_input");
    let outputCanvas = document.getElementById("output");
    let filterSelect = document.getElementById("filter_select");
    let currentFilter = "";

    file_input.addEventListener(
      "change",
      (e) => {
        let file = e.target.files[0];
        let reader = new FileReader();
        reader.onload = function (event) {
          let img = new Image();
          img.onload = function () {
            let ctx = permanentCanvas.getContext("2d");
            ctx.drawImage(
              img,
              0,
              0,
              permanentCanvas.width,
              permanentCanvas.height
            );
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      },
      false
    );

    function applyPermanent() {
      if (currentFilter) {
        applyFilter(permanentCanvas, permanentCanvas, currentFilter);
        currentFilter = "";
      }
    }

    function triggerFilter(filterName) {
      let mat = cv.imread(img_input);
      applyFilter(mat, filterName);
      mat.delete();
    }

    function previewFilter(filterName) {
      currentFilter = filterName;
      applyCurrentFilter();
    }

    function adjustIntensity() {
      if (currentFilter) {
        applyCurrentFilter();
      }
    }

    function applyCurrentFilter() {
      let srcCanvas = permanentCanvas; // Assuming permanentCanvas has the original image
      let dstCanvas = outputCanvas;
      applyFilter(srcCanvas, dstCanvas, currentFilter);
    }

    document
      .getElementById("applyButton")
      .addEventListener("click", applyPermanent);

    function applyFilter(sourceCanvas, destinationCanvas, filter) {
      let srcCtx = sourceCanvas.getContext("2d");
      let imageData = srcCtx.getImageData(
        0,
        0,
        sourceCanvas.width,
        sourceCanvas.height
      );
      let inputMat = cv.matFromImageData(imageData);
      let outputMat = new cv.Mat();
      let intensity = parseFloat(
        document.getElementById("filterIntensity").value
      );
      let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
      let anchor = new cv.Point(-1, -1);

      switch (filter) {
        case "GRAY":
          cv.cvtColor(inputMat, outputMat, cv.COLOR_RGB2GRAY);
          break;
        case "BRIGHTNESS":
          inputMat.convertTo(outputMat, -1, 1, 50);
          break;

        case "CONTRAST":
          inputMat.convertTo(outputMat, -1, 1.5, 0);
          break;

        case "COLOR_OVERLAY":
          let overlayColor = new cv.Mat(
            inputMat.rows,
            inputMat.cols,
            inputMat.type(),
            [Math.random() * 255, Math.random() * 255, Math.random() * 255, 255]
          );
          let alpha = 0.5;
          cv.addWeighted(
            inputMat,
            1 - alpha,
            overlayColor,
            alpha,
            0,
            outputMat
          );
          overlayColor.delete();
          break;
        case "THRESHOLD":
          cv.threshold(inputMat, outputMat, 128, 255, cv.THRESH_BINARY);
          break;
        case "CANNY":
          cv.Canny(inputMat, outputMat, 50, 100);
          break;
        case "BLUR":
          let ksize = new cv.Size(5, 5);
          cv.GaussianBlur(inputMat, outputMat, ksize, 0, 0, cv.BORDER_DEFAULT);
          break;
        case "ERODE":
          cv.erode(
            inputMat,
            outputMat,
            kernel,
            anchor,
            1,
            cv.BORDER_CONSTANT,
            cv.morphologyDefaultBorderValue()
          );
          break;
        case "DILATE":
          cv.dilate(
            inputMat,
            outputMat,
            kernel,
            anchor,
            1,
            cv.BORDER_CONSTANT,
            cv.morphologyDefaultBorderValue()
          );
          break;
        case "SEPIA":
          if (inputMat.type() === cv.CV_8UC1) {
            cv.cvtColor(inputMat, outputMat, cv.COLOR_GRAY2RGB);
          } else {
            inputMat.copyTo(outputMat);
          }

          for (let y = 0; y < outputMat.rows; y++) {
            for (let x = 0; x < outputMat.cols; x++) {
              let pixel = outputMat.ucharPtr(y, x);
              let outputPixel = [
                pixel[2] * 0.393 + pixel[1] * 0.769 + pixel[0] * 0.189,
                pixel[2] * 0.349 + pixel[1] * 0.686 + pixel[0] * 0.168,
                pixel[2] * 0.272 + pixel[1] * 0.534 + pixel[0] * 0.131,
              ];
              outputMat.ucharPtr(y, x)[0] = Math.min(255, outputPixel[2]);
              outputMat.ucharPtr(y, x)[1] = Math.min(255, outputPixel[1]);
              outputMat.ucharPtr(y, x)[2] = Math.min(255, outputPixel[0]);
            }
          }
          break;

        default:
          outputMat = inputMat.clone();
      }

      if (intensity < 1) {
        outputMat = blendWithOriginal(inputMat, outputMat, intensity);
      }

      cv.imshow(destinationCanvas, outputMat);
      outputMat.delete();
      inputMat.delete();
    }

    function blendWithOriginal(originalMat, filteredMat, intensity) {
      let blended = new cv.Mat();
      cv.addWeighted(
        filteredMat,
        intensity,
        originalMat,
        1 - intensity,
        0,
        blended
      );
      return blended;
    }
  </script>
</html>
